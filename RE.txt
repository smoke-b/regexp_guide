ПОЛЕЗНЫЕ ССЫЛКИ:
https://docs.python.org/3/library/re.html
http://www.regular-expressions.info
https://regexcrossword.com/

Регулярные выражения (regular expressions) - это мини-язык, с помощью которого удобно решать многие задачи, так или иначе связанные с текстовым поиском. Регулярные выражения применимы к любым данным, представимым в виде множества символов.

Регулярные выражения в Python становятся доступны, если подключить модуль re. Подробная документация доступна на оф. сайте: https://docs.python.org/3/library/re.html#

Регулярные выражения не следует использовать, если вы ищите в тексте подстроку с заранее известным содержимым. В этих случаях пользуйтесь функциями строк, такими как: str.find, str.replace, str.split.

Регулярные выражения используются там, где вы можете дать лишь неоднозначное описание того, что вы хотите найти. Фактически, регулярное выражение - это шаблон. Под это описание (шаблон) могут подходить разные подстроки в тексте. Мини-язык, использующийся для описания этих шаблонов, содержит довольно много специальных конструкций, и может показаться поначалу немного сложным, однако это очень мощный инструмент, способный удовлетворить большинство потребностей, связанных с низкоуровневым анализом текстов. С помощью регулярных выражений вы можете задавать вопросы, такие как «Соответствует ли эта строка шаблону?», или «Совпадает ли шаблон где-нибудь с этой строкой?». Вы можете использовать регулярные выражения, чтобы изменить строку или разбить ее на части различными способами. Про то, как строить р.в. пишут целые книжки (Mastering Regular Expressions, Jeffrey Friedl, published by O’Reilly). В этом же документе - попытка кратко, но полно перечислить функциональные возможности регулярных выражений.

Одну и ту же задачу можно решить с помощью составленных по-разному р.в., которые могут работать быстрее или (сильно) медленнее. При обработке больших массивов данных это может быть существенно, так что следует обращать внимание на то, насколько оптимально составлено ваше р.в.. Для этого необходимо иметь хотя бы минимальное представление о том, как движок р.в. идёт по тексту и осуществляет поиск шаблона. Полезно, уже имея начальный опыт работы с р.в., почитать статьи про оптимизацию р.в.

Существуют задачи, которые можно сделать с помощью регулярных выражений, но выражения оказываются слишком сложными и запутанными - возможно, в этих случаях лучше написать обычный Python код. Прежде чем использовать составленное вами р.в. в ваших задачах, особенно если оно получилось длинное и сложное, хорошо бы его потестировать, чтобы не получить неверные результаты в самых неожиданных местах.

Ниже описаны:
-правила составления шаблонов регулярных выражений
-функции и объекты из модуля re для работы с этими шаблонами

Шаблон регулярного выражения в python задаётся с помощью строки (объекта типа str), содержащей внутри себя определение р.в.. Эта строка передаётся как аргумент в разнообразные функции модуля re. Подобный способ задания р.в. порождает некоторые проблемы, связанные с тем, что, с одной стороны, есть
-правила шаблонов регулярных выражений, общие для самых разных языков программирования;
-правила задания строковых объектов внутри python (касающиеся экранированных последовательностей).
Эти правила конфликтуют, однако эта проблема решаема. Об этом - ниже, сейчас же важно иметь в виду, что то, о чём пойдёт речь в первом разделе, касается именно правил составления шаблонов и является элементами синтаксиса регулярных выражений, а не элементами синтаксиса самого языка Python. Правила эти в целом стандартизованы и похожи во многих языках программирования и продвинутых текстовых редакторах (некоторые отдельные фичи, впрочем, могут быть не поддержаны тут или там).

================================================================================================
1. Правила составления шаблонов.

Большинство букв и символов соответствуют в точности сами себе. Исключения составляют метасимволы и специальные последовательности, начинающиеся с метасимвола '\'.

1.1 Список метасимволов:
\ . ^ $ * + ? { } [ ] ( ) |

1.2 Список специальных последовательностей:
1.2.1  \d \D \s \S \w \W \<число> \A \Z \b \B         - спец. последовательности регулярных выражений;
1.2.2  \\ \a \b \f \n \r \t \v \x... \u... \U... \ooo - спец. последовательности строковых литералов Python-a, поддержаные регулярными выражениями;
1.2.3  \<метасимвол>                                  - экранирование метасимволов (превращает их в обычные символы);
1.2.4  \<любая другая буква из [a-zA-Z]>              - некорректная последовательность (в новых версиях питона - это ошибка в шаблоне)
1.2.5  \<любой другой символ>                         - означает сам любой другой символ (р.в. делает вид, что не заметило ненужный '\')

Собственно, вот и все правила: всё остальное посвящено тому, какой метасимвол и какая специальная последовательность что обозначает.

================================================================================================
1.3 ВВОД СИМВОЛОВ, ЭКРАНИРОВАНИЕ, КЛАССЫ СИМВОЛОВ.
1.3.1  \
Экранирует метасимволы (в том числе себя), или же служит началом специальной последовательности.

1.3.2  .
Любой символ, кроме перевода на новую строку (\n). Если включён флаг re.S или re.DOTALL, то и \n тоже.

1.3.3  [ ]
Класс символов. Обозначает: искать символ, являющийся (или не являющиеся) одним из указанных (внутри квадратных скобок).
Тонкости:
-все метасимволы, кроме '\', теряют свою силу внутри класса символов и не требуют экранирования.
-все специальные последовательности (кроме \<число> \A \Z \B \b) работают согласно определениям (описанным ниже). \b внутри классов символов обозначает ASCII Backspace.
-диапазон символов с помощью '-':  [a-z0-9]
-отрицание с помощью '^' на первом месте:  [^<cимволы, которые нам не подходят>].  (Пример: [^^] - всё, кроме '^')
-чтобы указать символ '\', его надо сэкранировать: \\  (Пример: [ab\][cd] - означает искать a, b, ], [, c или d.)
-чтобы указать символ '-', его надо cэкранировать, или поставить на первое или последнее место внутри скобок.
-чтобы указать символ '^', его надо cэкранировать, или поставить на не первое место внутри скобок.
-чтобы указать символ ']', его надо сэкранировать, или поставить на первое место внутри скобок.

1.3.4  Сокращения для классов символов.
\d = [0-9] + символы десятичных цифр других языков (decimal digit)
\D = [^\d]
\s = [ \t\n\r\f\v] + пробельные символы (например неразрывный пробел) (whitespace character)
\S = [^\s]
\w = [a-zA-Z0-9_] + алфавиты других языков и цифровые символы (напр, ¾, ² и т.п. не входящие в \d)
\W = [^\w]
Также эти сокращения можно использовать в самих классах символов: [\s.,!?]
(Если включён флаг re.ASCII, то \d, \s, \w означают в точности [0-9], [ \t\n\r\f\v] и [a-zA-Z0-9_]).

1.3.5
Поддержанные в регулярных выражениях escape-последовательности из Python-а:
\\ - символ обратного слеша.
\t - табуляция (Horizontal Tab (TAB))
\n - новая строка (Linefeed (LF))
\r - возврат каретки (Carriage Return (CR))
\f - перевод страницы, редкий символ (Formfeed (FF))
\v - вертикальная табуляция, вряд ли вам встретится (Vertical Tab (VT))
\a - вряд ли вам встретится (Bell (BEL))
\b - вряд ли вам встретится (Backspace (BS)), как backspace трактуется только внутри класса символов. В остальных случаях \b обозначает границу слов (см. ниже)
\xXX - символ с шестнадцатеричным номером XX
\uXXXX - символ с шестнадцатеричным номером XXXX
\UXXXXXXXX - символ с шестнадцатеричным номером XXXXXXXX
\ooo - ASCII-символ в восьмеричным номером ooo, 0 <= ooo <= 0o377 (в отличие от строковых литералов, поддержаны только ascii-символы)

Последние 4 escape-последовательности: задание символов по их числовому коду. X - это шестнадцатеричная цифра (0123456789ABCDEF); o - восьмеричная (01234567).
Для перевода строки исторически используются: \n (UNIX), \r\n (DOS/WINDOWS), или \r (старые MAC).

================================================================================================
1.4 ГРУППИРОВКИ
1.4.1  (...)
Выделение внутри шаблона некоторой его части (подшаблона). Это используется в разнообразных операциях (обратные ссылки, вариативность, квантификаторы, sub, groups, split, findall и т.д.).
Групп в шаблоне может быть много, группы могут быть вложенными.
Все группы нумеруются последовательно слева направо в порядке открывающих их скобок, начиная с единицы. Содержимое групп запоминается ("захватывается") и может быть использовано.

1.4.2  (?P<name>...)
Именованная группа. Эта группа, помимо номера, имеет ещё и имя "name", которое можно использовать в некоторых случаях.

1.4.3  (?:...)
Группа без захвата содержимого. Группа не нумеруется, её содержимое не запоминается, на неё нет обратной ссылки. Такое поведение иногда бывает удобно. Квантификаторам и '|' не важно, группа с захватом содержимого или нет.

1.4.4  \number  (то есть, \1 \2 ... \99)
Обратная ссылка на точное содержимое группы с номером number (в диапазоне [1...99]).
-двузначные номера: \43 интерпретируется как группа 43, а не группа 4 с последующим символом 3. (Используйте '(\4)3')
-если первая цифра 0, или номер - более, чем 2-значный, то это будет расценено как восьмеричный номер символа (см. 1.2.2, \ooo)

1.4.5  (?P=name)
Обратная ссылка на именованную группу. Обраные ссылки сами группами не являются.

1.4.6 ### Важное замечание (см 1.6 прежде):
В случае, если к группе применяется квантификатор, будет захвачено содержимое последнего соответствия. Например:
-группа в выражении "а(b|c)*" в строке "abcb" захватит "c";
-р.в. (a|b)+\1 в строке "aabba" найдёт "aabb".

1.4.7 ### Важное замечание (см 1.5.1 прежде):
Средует различать случаи, когда группа пуста и когда она не определена:
-в регулярном выражении '(a?)' группа может быть пуста или содержать 'a', но всегда определена.
-в регулярном выражении '(а)?' группа может быть не определена, но если определена - то всегда содержит символ 'a'.
-в регулярном выражении '(a?)b|cсс' группа может быть не определена (если строка - это 'ccc').
При обращении к содержимому пустой группы, вы всегда получите "".
При обращении к не определённой группе, вы получаете разный результат в зависимости от контекста использования и версии Python.
Подробнее - см. замечание 4.4.
Сравните:
# re.match (r'b(b)?x\1', 'bxb')   # группа не определена
# re.match (r'b(b?)x\1', 'bxb')   # группа пуста

1.4.8 ### Важное замечание (см 1.5.1 и 3.3.7 прежде):
Начиная с версии питона 3.5, на не определённые группы (unmatched groups) можно ссылаться при замене (функции sub и subn): обратные ссылки на такие группы считаются пустыми строками. Это позволяет писать, например, следующее:
re.sub (r'a(.)b|c(.)d|e(.)f', r'\1\2\3', 'e1fc2da3bc4d')  # вернёт "1234"
В более ранних версиях подобное выражение выдаст ошибку.
В некоторых реализациях для решения подобных задач есть Branch Reset Groups: http://www.regular-expressions.info/branchreset.html
Однако обратная ссылка на не определённую группу в определении шаблона не эквивалентна пустой строке: выражение '(a(.)b|c(.)d)\1\2' не даст соответствия в строке 'a1b1'.

================================================================================================
1.5 ВАРИАТИВНОСТЬ
1.5.1  |
Или. "A|B", "A|B|C|D..." - искать А или B (или C, или D,...), где A,B,C,D - регулярные выражения. Действие оператора распростраяется до границы всего шаблона или группы, в которой он находится.
-проверка вариантов производится последовательно слева направо, и если совпадение получено (и шаблон целиком подходит) - остальные варианты не проверяются.
(выражение '(a|abc)bc' в 'abcbc' найдёт "abc", но '(a|abc)bc!' в 'abcbc!' найдёт "abcbc!").

1.5.2  (?(id)yes-pattern|no-pattern)
Если группа идентификатором "id" (в качестве которого указывается либо номер группы, либо её имя) определена (но, возможно, пуста), то проверяется шаблон "yes-pattern", в противном же случае проверяется шаблон "no-pattern". Группой само это выражение не является.
Пример: регулярное выражение '(a)?(?(1)b|c)' в строке 'abcacb' даст 3 вхождения: "ab", "c", "c".

================================================================================================
1.6 КВАНТИФИКАТОРЫ
1.6.1  * + ? { }
Применяется к стоящему перед этим символу, классу символов, группировке или обратной ссылке. Бывает:

a) Жадная (greedy):
*     : искать 0 или более раз
+     : искать 1 или более раз
?     : искать 0 или 1 раз
{n}   : искать n раз
{n,m} : искать не менее n, но не более m раз
{n,}  : искать n или более раз
{,m}  : = {0,m}

Движок попытается сначала захватить так много вхождений, как это возможно. Если следующая далее часть шаблона не соответствует строке, движок будет последовательно уменьшать кол-во вхождений в надежде, что при каком-то значении квантификатора шаблон совпадёт со строкой.
Пример: шаблон a[bcd]*b в строке 'abcbd' соответствует 'abcb'

b) Ленивая (lazy):
*? +? ?? {n}? {n,m}? {n,}? {,m}?
В этом режиме, наоборот, движок будет искать так мало вхождений, как это только воможно, последовательно увеличивая кол-во вхождений.
Пример: шаблон a[bcd]*?b в строке 'abcbd' соответствует 'ab'

1.6.2 ### Важное замечание:
Квантификаторы проверяют, что несколько подряд идущих частей строки одновременно соответствуют одному и тому же регулярному выражению, но не проверяют, что эти части - одинаковы. Например, регулярное выражение '(aa|bb)+' соответствует как строке 'aaaa' и 'bbbb', так и строке 'aabb'.
Если нужно проверить именно совпадение повторяющихся частей, придётся написать чуть более хитро: например, '(аа)+|(bb)+, или, '(aa|bb)\1*'

================================================================================================
1.7 ПОЗИЦИОНИРОВАНИЕ
Иногда требуется тем или иным образом уточнить местоположение шаблона в исходной строке.
Следующие метасимволы и спец.последовательности не соответствуют никаким символам в строке, но являются условиями на то, что должно стоять слева или справа относительно текущей позиции (между символами) в строке. Они не вызывают движок для прохода по строке и не охватывают никаких символов, эти условия просто могут быть вополнены, или нет.

1.7.1  \A \Z
Начало (\A) и конец (\Z) строки. Под строкой имеется в виду объект типа str, в котором выполняется поиск р.в.
Пример: регулярное выражение 'f\Z' не будет соответствовать строке 'f\n'.

1.7.2  ^ $
Начало (^) и конец ($) строки. Под строкой, по умолчанию, имеется в виду объект типа str, в котором выполняется поиск р.в.
Однако, если флаг re.MULTILINE включён, то эти символы будут соответствовать ещё и началу и концу строки в привычном текстовом понимании (т.е. строк, разделённых символом перевода строки), т.е., позициям в тексте непосредственно после и перед \n.
Кроме того, независимо от флага re.MULTILINE, $ будет соответствовать позиции непосредственно перед последним \n, если строка целиком (как объект) на него заканчивается. То есть, регулярное выражение 'f$' будет найдено в строке 'f\n' в любом случае, а в строке 'f\n\n' - только если включён флаг re.MULTILINE.

1.7.3  \b
Граница слова: текущая позиция находится между символами из классов \w и \W (в любом порядке), либо между \w и началом/концом строки.

1.7.4  \B
НЕ граница слова, то есть, не \b.

1.7.5 ### Важный момент:
\A \Z \b и \B не работают внутри классов символов, и более того: \b внутри класса символов означает символ backspace!

1.7.6 ### Важный момент:
Рекомендуется всегда использовать метасимволы ^ и $ вместе с флагом re.MULTILINE.
В этом случае можно считать, что просто все символы "\n" окружены "невидимыми" метасимволами следующим образом: "...$\n^...". 
- выражение '^\s+1', в '1\n\n1' соответствует подстроке '\n1', а не '\n\n1' (с флагом re.MULTILINE)
- выражение '1\s+$', в '1\n\n1' соответствует подстроке '1\n', а не '1\n\n' (с флагом re.MULTILINE)
Однако, всё же, НЕЛЬЗЯ считать, что это символы.
Это именно условия на позицию в строке между символами. В частности, бессмысленно говорить про порядок условий на конкретную позицию в строке. Данная позиция может либо удовлетворять всем перечисленным на неё условиям, либо нет. Нельзя сказать, что в пустой строке её "начало" идёт перед её "концом": выражения '\n^$\n' и '\n$^\n' эквивалентны.
- выражение '1\n.*$.*^.*\n1' соответствует строке '1\n\n1' (с флагом re.MULTILINE);
- выражение 'aa.$|^.bb' соответствует в строке 'aa\n\nbb' двум непересекающимся фрагментам (с флагами re.MULTILINE|re.DOTALL);
Кроме того, если каждый символ может быть найден или захвачен выражением только один раз, то условия не могут быть найдены или захвачены. Одно и то же условие в одной и той же позиции может быть проверено дважды:
- выражение '($\n$){2}' соответствует строке '\n\n' целиком (с флагом flags=re.MULTILINE): в этой строке всего три текстовых строки, и, соответственно, всего 3 их конца: однако регулярное выражение 4 раза проверяет условие на конец строки.
- выражение '\d?\b' в строке "1" будет найдено 2 раза, и вхождения не будут считаться пересекающимися.
(вышеотмеченное верно также и для \b, \B, \A, \Z, и всех проверок, о которых речь идёт ниже).

================================================================================================
1.8 ПРОВЕРКИ
Проверки - это специальные конструкции, которые проверяют, что в строке слева или справа от текущего положения находится текст, соответствующий специальным образом заданному регулярному выражению. Проверки, в отличие от обычных р.в., не меняют текущую позицию в строке (т.е., не "съедают" ту часть исходной строки, которая соответсвтует условию в проверке). Поэтому проверки можно использовать для того, чтобы задать одновременно несколько регулярных выражений на какую-то часть строки.
Проверки не являются группами.

1.8.1  (?=...)    Опережающая позитивная проверка.
1.8.2  (?!...)    Опережающая негативная проверка.
1.8.3  (?<=...)   Ретроспективная позитивная проверка.
1.8.4  (?<!...)   Ретроспективная негативная проверка.
Проверки бывают опережающими и ретроспективными, позитивными и негативными.
Опережающие - проверяют содержимое строки справа от текущего положения.
Ретроспективные - слева. При этом, выражение для ретроспективной проверки должно быть таким, что по нему можно точно определить длинну соответствующей ему подстроки (т.е. конструкции типа ".*" запрещены).
Позитивные - проверяют, что строка соответствует (начинается или заканчивается) указанному (вместо "...") регулярному выражению.
Негативные, наоборот, выполняются тогда, когда строка указанному регулярному выражению не соответствует.

Выражение "Вася (?=Пупкин)" будет соответствовать подстроке "Вася " только в том случае, если в исходной строке после этого следует "Пупкин" (и что угодно после этого). Аналогично, "(?<=Вася )Пупкин" будет соответствовать подстроке "Пупкин", только если слева было "Вася " (и что угодно до этого).
Проверки задают условие на часть примыкающего левого или правого контекста, но не проверяют на точное соответствие весь кусок строки слева/справа до начала/конца: то есть, выражение "(?<=a)b(?=c)" будет найдено в строке "XabcX".

================================================================================================
1.9 ПРОЧЕЕ
1.9.1  (?#...)
Комментарий. Всё, что написано вместо "...", будет проигнорированно. Группой не является.

1.9.2  (?aiLmsux)
Установить тот или иной флаг, но лучше этим не пользоваться - вместо этого используйте аргумент flags у функций.

================================================================================================
2. Флаги

Флаги - это специальные настройки, которые влияют на работу всего регулярного выражения.
Флаги выставляются с помощью именованного аргумента flags, который есть у всех важных функций из модуля re.
Несколько флагов можно установить, используя битовую операцию "|": например, flags = re.M|re.S|re.I
Почти все флаги имеют однобуквенное и полное имя - нет разницы, какое из двух использовать.

2.1  re.M  re.MULTILINE
Метасимволы '^' и '$' дополнительно начинают обозначать начала и концы строк в обычном "текстовом" смысле, т.е., позиции непосредственно после (для '^') и перед (для '$') каждым символом '\n'.

2.2  re.S  re.DOTALL
Метасимвол '.' начинает обозначать вообще любой символ (включая '\n').

2.3  re.I  re.IGNORECASE
Регистр символов перестаёт иметь значение.

2.4  re.A  re.ASCII
Спец.последовательности \w, \d, \s будут содержать только символы из первой половины ASCII-таблицы, вместо символов из всего Unicode. Связанные с этим \W, \D, \S, \b, \B, соответствнно, тоже будут работать иначе.

2.5  re.X  re.VERBOSE
Позволяет писать комментарии прямо внутри регулярного выражения и разбивать его на несколько строк (полезно, если оно становится большим и сложным).
Рекомендуется пользоваться многострочными raw-строками в этом случае (r""" ... """). Правила такие:
-все пробелы и символы переводов строк игнорируются, если только они не использованы внутри класса символов;
-знак '#' означает начало комментария (до конца строки);
-чтобы указать '#' или пробел - надо их сэкранировать или поместить внутрь класса символов, для символа перевода строки надо всегда использовать '\n';

Также вместо этого режима можно пользоваться автоматической конкатенацией строк в питоне (и, таким образом, разбивать строку на части, каждую из которых писать на новой строке): https://docs.python.org/3.4/reference/lexical_analysis.html#string-literal-concatenation

2.6
Флаги re.U, re.UNICODE, re.L, re.LOCALE устарели и их не стоит использовать.
Флаг re.DEBUG печатает на экран некоторую техническую информацию про регулярное выражение.

================================================================================================
3. Функции и объекты из модуля re

Модуль re определяет два типа объектов:
-Regular Expression Objects (SRE_Pattern, скомпилированные шаблоны)
-Match Objects (SRE_Match, совпадения).

Для того, чтобы использовать регулярные выражения в операциях поиска, замены или разбиения строк, регулярное выражение сначала компилируется в специальный объект типа SRE_Pattern. Компиляция может производиться скрыто от вас в момент вызова функций, или же явно заранее, в зависимости от выбранного вами способа вызова функций.
Если регулярное выражение найдено в строке, то для каждого совпадения будет возвращён объект типа SRE_Match, который содержит всю необходимую информацию о совпадении.

Модуль re состоит из:
-функций модуля верхнего уровня
-функций Regular Expression Objects
-функций Match Objects
Многие функции в качестве необязательного аргумента могут принимать набор флагов (описанных выше).

3.1  Конфликт между синтаксисом строковых литералов Python и синтаксисом регулярных выражений.
Выше описаны правила составления шаблонов регулярных выражений. Но для того, чтобы шаблон скомпилировался, его определение необходимо передавать в функции модуля re в виде строки (str). Таким образом, сначала должен быть создан объект типа str, содержащий определение р.в., а потом уже, с его помощью, компилируется и создаётся р.в..
Но существуют и свои правила определения питоновских строк. Например, по правилам строковых литералов, "\\" - это один символ. Чтобы искать символ '\' в строке, по правилам регулярных выражений он должен быть экранирован, т.е., определение р.в. должно содержать два бэкслеша. Чтобы определить в питоне строку, в которой стоит два бэкслеша подряд, надо в коде написать "\\\\". Точно так же, написанное в коде "\b" породит python-строку из одного символа backspace, а чтобы определить для регулярных выражений спец.последовательность \b, обозначающую границу слова, необходимо будет написать в коде "\\b". Написанное в коде "\1" означает один символ с номером 1 в ASCII-таблице, а не обратную ссылку на группу с номером 1.

Всякое выражение, которое вы напишете, будет обработано:
-сначала по правилам задания обычных строк в python-е: все escape-последовательности строковых литералов превратятся в соответствующие символы (\\ в один '\', \b в backspace и т.д.);
-только потом движком регулярных выражений, согласно синтаксису р.в., описанному выше (и тут есть свои escape-последовательности).
(Если вызвать функцию print () от строки, которая содержит ваше определение р.в., то на экран будет выведено в точности то, что отправится во второй пункт этой цепочки, т.е. то, чем и будет являться ваше регулярное выражение на самом деле).
Это создаёт некоторые неудобства. Но их можно избежать, используя так называемые raw-строки. Грубо говоря, raw-строки отключают первый пункт.
Всегда используйте raw-строки для определения регулярных выражений.

3.2  Raw strings
Чтобы задать raw-строку, используется префикс 'r':
r'...', r"...", r"""...""" или r'''...'''
В raw-строках escape-последовательности строковых литералов отключены, и cимвол '\' означает сам себя. Определение регулярного выражения, записанное в raw-строке, будет передано в функцию модуля re без изменений. (В частности, r'\n' - это два символа (бэкслеш и буква n), и это будет воспринято как спец.последовательность для символа новой строки не интерпретатором Python, а уже модулем регулярных выражений. В данном случае разницы нет, но для \b, поиска слешей, обратных ссылок и некоторых других вещей - есть).

Маленькая неприятность raw-строк: в raw-строках последовательности \" и \' - это всегда два символа: backslash и кавычка, backslash одновременно экранирует следующую за ним кавычку, и рассматривается как самостоятельный символ. Из этого следует:
- r"\"" - это строка из двух символов.
- в raw-строку нельзя нормально вставить кавычку того же типа, какой используется для определения raw-строки: без backslash она будет воспринята как конец строки, а с backslash - как два символа.
- даже raw-строка не может заканчиваться на '\': кавычка следом за ним будет воспринята как символ строки, а не как знак её конца. r'\', r'''\''' - это синтаксические ошибки.
Эти проблемы можно решить, используя конкатенацию строк.
Та же особенность связана со специальной последовательностью \<newline>: подобное будет таки воспринято как разрыв литерала и его продолжение на новой строке, но символы backslash и '\n' появятся в строке.
https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals

================================================================================================
3.3  ФУНКЦИИ верхнего уровня

Общие правила для поиска совпадений в строке:
- поиск всегда производится последовательно слева-направо;
- вхождения не пересекаются;
- если пустое вхождение подходит под ваш шаблон, подумайте - то ли это, что вы хотели?

3.3.1 re.search (pattern, string, flags=0)       [возвращает SRE_Match или None]
3.3.2 re.match (pattern, string, flags=0)        [возвращает SRE_Match или None]
3.3.3 re.fullmatch (pattern, string, flags=0)    [возвращает SRE_Match или None]
Функция search ищет шаблон в строке. Возвращается объект типа SRE_Match (см. ниже), соответствующий первому вхождению. Если совпадений нет, возвращается None.
Функция match проверяет, что строка начинается с заданного регулярного выражения. Это фактически эквивалентно re.search, в начало шаблона которого добавлено \A.
Функция fullmatch проверяет, что вся строка целиком подходит под заданный шаблон. Это фактически эквивалентно re.search, в начало шаблона которого добавлено \A, а в конец - \Z.

3.3.4 re.findall (pattern, string, flags=0)      [возвращает список строк или список кортежей из групп]
Найти все вхождения шаблона в строке.
ПУСТЫЕ вхождения: учитываются: re.findall (r'b*', 'abc') == ['', 'b', '', '']
Возвращаемое значение зависит от того, есть ли внутри pattern группы (с захватом содержимого):
-если нет, то возвращается список вхождений как список строк.
-если есть, то возвращается список (равный числу вхождений), каждый элемент которого является результатом вызова функции groups () от соответствующего вхождения (то есть, является кортежом, состоящим из, последовательно, содержимого всех групп для этого вхождения). Пустым и не определённым группам соответствует "". Например: 
>>> re.findall (r'\d(\d(\d?))?', '123_45_6_')
[('23', '3'), ('5', ''), ('', '')]

3.3.5 re.finditer (pattern, string, flags=0)     [возвращает итератор по вхождениям]
Аналогично findall, но функция возвращает итератор, который будет последовательно выдавать по SRE_Match для каждого вхождения.
(Если нужен список из SRE_Match, надо преобразовать итератор в список.)

3.3.6 re.split (pattern, string, maxsplit=0, flags=0)     [возвращает список из частей строк (и групп в разделителе)]
Разделить строку string на части, используя в качестве разделителя шаблон pattern. Если указан положительный maxsplit, то функция делает не более maxsplit разделений.
Если строка начинается (или кончается) на разделитель, то считается, что первая (или последняя) часть состоит из пустой строки ("").
ПУСТЫЕ вхождения: игнорируются, разделитель не может состоять из нуля символов. В частности, r'\b' не может быть использовано в качестве разделителя.
Возвращаемое значение зависит от того, есть ли внутри pattern группы (с захватом содержимого):
-если нет, то возвращается список частей, на которые строка была порезана (без разделителей).
-если есть, то в возвращаемый список ещё добавляются элементы, соответствующие содержанию всех групп из шаблона-разделителя. Пустым группам соответсвует "", не определённым - None. Например:
>>> re.split (r'\d(\d(\d?))?', '123_45_6_')
['', '23', '3', '_', '5', '', '_', None, None, '_']


3.3.7 re.sub (pattern, repl, string, count=0, flags=0)    [возвращает изменённую строку]
3.3.8 re.subn (pattern, repl, string, count=0, flags=0)   [возвращает tuple (изменённая строка, количество замен)]
Заменить вхождения шаблона pattern в строке string на repl, и возвратить изменённую строку. Если шаблон не найден, строка возвращается неизменной.
Если указан положительный count, то производится не более conut замен.
Сначала ищутся все вхождения, а потом производятся все замены: re.sub ('bc|(?<=c)b', '', 'bcb') == ''.
ПУСТЫЕ вхождения: учитываются, если только не контактируют с другими непустыми вхождениями:
re.sub ('x*', '-', 'abc') == '-a-b-c-'
re.sub ('b*', '-', 'abc') == '-a-c-'
В качестве заменителя repl может выступать строка, или же функция.

Если repl - это строка, то для неё действуют следующие правила:
- (совет: используйте raw-строки для определения repl, типичная ошибка: написать '\1' в качестве repl)
- все специальные последовательности строковых литералов Python-a, поддержаные регулярными выражениями (см. 1.2.2), заменяются на соответствующие им символы. Так, \n - это одиночный символ новой строки, а если repl должна состоять из двух символов - '\' и 'n', то надо писать '\\\\n' или r'\\n'. Во всех остальных случаях \<что угодно>, кроме обратных ссылок, backslash остаёнется в заменителе.
- \1, \2, ... \99 - обратные ссылки (простой вариант). Тонкости:
--- '\1' - это ascii-символ с восьмеричным номером 1 по правилам строковых литералов;
--- '\\1' или r'\1' - обратная ссылка на группу 1;
--- r'\10' расценивается как ссылка на группу 10, а не как группа 1 и символ '0';
--- r'\100', r'\001', r'\02 - это символы с восьмеричными номерами 100, 1 и 2;
- \g<name> - обратные ссылки (продвинутый вариант), где в вместо name может быть номер или имя группы
- \g<0> - "нулевая" группа, содержащая подстроку, соответствующую всему регулярному выражению.
- пустые группы возвращают "". Например: 
>>> re.sub (r'\d(\d?(\d?))', r'\1\2', '123_45_6_')
'233_5__'
- не определённые группы - "" (или порождают ошибку в версиях Python ранее 3.5)
 
Если repl - это функция, тогда:
-функция будет вызвана для каждого найденного вхождения;
-функции передаётся один аргумент (его тип - SRE_Match), соответствующий заменяемому вхождению;
-функция должна возвращать строку, на которую должно быть заменено данное вхождение.


3.3.9 re.escape (string)                         [возвращает изменённую строку]
Экранировать в строке string все символы, кроме [a-zA-Z0-9_]. Функция нужна в том случае, если вы хотите использовать string как часть регулярного выражения: string может случайно содержать элементы, воспринимаемые регулярными выражениями как метасимволы или спец. последовательности. Функция гарантирует, что, после этой операции, строка будет воспринята движком регулярных выражений просто как последовательность символов из string.

3.3.10 re.compile (pattern, flags=0)             [возвращает SRE_Pattern]
Скомпилировать шаблон. Функция возвращает объект типа SRE_Pattern.
Оптимизирует затраты на компиляцию, если один и тот же шаблон надо использовать многократно.

================================================================================================
3.4  ФУНКЦИИ уровня SRE_Pattern
3.4.1 SRE_Pattern.search (string[, pos[, endpos]])      [возвращает SRE_Match или None]
3.4.2 SRE_Pattern.match (string[, pos[, endpos]])       [возвращает SRE_Match или None]
3.4.3 SRE_Pattern.fullmatch (string[, pos[, endpos]])   [возвращает SRE_Match или None]
3.4.4 SRE_Pattern.findall (string[, pos[, endpos]])     [возвращает список строк или список кортежей из групп]
3.4.5 SRE_Pattern.finditer (string[, pos[, endpos]])    [возвращает итератор по вхождениям]
Эти функции эквивалентны соответствующим функциям уровня модуля, но дополнительно могут быть использованы необязательные аргументы pos и endpos, ограничивающие диапазон в строке, в котором будет производиться поиск.
Использование pos и endpos не эквивалентно поиске в string[pos:endpos], однако, эквивалентно поиске в строке string[:endpos]. Фактически, происходит следующее:
- любые вхождения до позиции pos учитаны не будут;
- строка будет обрезана на позиции endpos.
Таким образом, следует учитывать, что:
- все индексы для SRE_Match отсчитываются от реального начала строки string;
- символы ^, \A соответствуют началу строки string, но не позиции начала поиска (если pos > 0).
- напротив, $, \Z и \b начинают работать иначе для позиции конца поиска, т.к. фактически срока обрезается в этом месте, позиция становится концом строки;
- фактическое укорачивание строки влияет на работу проверок около позиции конца поиска.

3.4.6 SRE_Pattern.split (string, maxsplit=0)            [возвращает список из частей строк (и групп в разделителе)]
3.4.7 SRE_Pattern.sub (repl, string, count=0)           [возвращает изменённую строку]
3.4.8 SRE_Pattern.subn (repl, string, count=0)          [возвращает tuple (изменённая строка, количество замен)]
Эти функции эквивалентны соответствующим функциям уровня модуля.


3.5  ФУНКЦИИ уровня SRE_Match
- Объект SRE_Match соответствует одному найденному вхождению регулярного выражения в строке. Он содержит разнообразную информацию об этом вхождении: где оно начинается и заканчивается, подстрока соответствия, содержимое групп...
- Многие функции принимают в качестве аргументов номера или имена групп, для которых требуется получить ту или иную информацию. В зависимости от переданных аргументов, они могут вести себя по-разному.
- Дополнительная группа с номером 0 соответствует всему регулярному выражению, как если бы оно целиком было дополнительно помещено в объемлещую группу.

3.5.1  Преобразование в bool
Результат преобразования в bool для SRE_Match всегда равен True. Вместе с этим, функции search, match и fullmatch возвращают None, если совпадение не найдено. Это позволяет писать так:
match = re.search (pattern, string)
if match:
    process (match)

3.5.2 SRE_Match.group ([group1, ...])     [подстрока или кортеж из подстрок]
Вернуть содержимое группы (или групп): 
- вызванная без аргументов: функция возвращает соответствие для всего регулярного выражения.
- с одним аргументом: функция возвращает содержимое соответствующей группы (может быть использован как номер, так и имя группы).
- аргументов более одного: будет возвращён кортеж из строк, соответствующих содержимым переданных в качестве аргументов групп.
Для не определённых групп возвращается None.
Для групп, которые находятся внутри квантификаторов, будет возвращено последнее встретившееся вхождение: re.match (r"(..)+", "a1b2c3").group (1) == 'c3'

3.5.3 SRE_Match.groups (default=None)     [кортеж из подстрок]
3.5.4 SRE_Match.groupdict (default=None)  [dict из подстрок]
Функция groups возвращает кортеж, состоящих из содержимых всех групп в р.в.:  (group(1), group(2), ..., group(N))
Функция groupdict возвращает dict, состоящий из пар {'имя именованной группы' : 'её значение'} для всех именованных групп.
Не определённым группам будет соответствовать значение переменной default.
 
3.5.5 SRE_Match.start ([group])           [возвращает число]
3.5.6 SRE_Match.end ([group])             [возвращает число]
3.5.7 SRE_Match.span ([group])            [возвращает кортеж из двух чисел]
Получить индексы начала и конца вхождения в исходной строке для всего р.в. (вызов без аргументов) или отдельной группы (если указана группа). 
Индекс конца - индекс следующего символа, после последнего во вхождении. Если вхождение пустое - start и end совпадают.
Для не определённой группы индексы равны -1.
Функция span эквивалентна кортежу из (m.start(group), m.end(group)). 

3.5.8 SRE_Match.string
Переменная, хранящая исходную строку, в которой производился поиск.
(m.group(g) эквивалентно m.string[m.start(g):m.end(g)] для группы g, если она определена)


====================================================================
4. ОСОБЫЕ МОМЕНТЫ И СОВЕТЫ:
4.1
Если то, что вы хотите сделать, можно сделать с помощью вызова обычной функции питоновских строк (str.split, str.replace, str.find), не используйте регулярные выражения. Например, если вы ищете фиксированную строку или одиночный символ. Эти функции будут работать быстрее.

4.2
Должны ли вы использовать функции верхнего уровня, или заранее компилирвоать регулярные выражения? Это зависит от того, как часто будет использоваться регулярное выражение. Если регулярное выражение используется только в одном месте кода, то функции верхнего уровня, вероятно, более удобны. Если программа содержит много регулярных выражений, или повторно использует одни и те же в нескольких местах, то будет целесообразно собрать все определения в одном месте, в разделе кода, который предварительно компилирует все регулярные выражения.

4.3
Остерегайтесь регулярный выражений, которым удовлетворяют пустые строки. При их использовании будет происходить следующее:
1. findall будет возвращать пустые вхождения между любыми двумя символами, если только символ справа не будет являться частью другого непустого вхождения:
>>> re.findall (r'(bb)?', 'abbc') == ['', 'bb', '', '']
2. sub будет заменять пустые вхождения, если только оно не примыкает к другим непустым вхождениям:
>>> re.sub (r'(bb)?', '!', 'abbc') == '!a!c!'
3. split - не будет делить по пустым вхождениям.

4.4
Остерегайтесь не определённых групп (unmatched groups).
При обращении к не определённой группе, вы получаете разный результат в зависимости от контекста использования и версии Python:
- в шаблоне рег.выражения, используя обратные ссылки - соответствия никогда не будет;
- в шаблоне-заместителе функций замены - ошибку или '' (см. 1.4.8);
- в функции match.group() - всегда None;
- в функции match.groups() и match.groupdict() - значение переменной default (=None по умолчанию);
- при вызове re.findall() - всегда пустая строка;
- при вызове re.split() и использованием групп в разделителе - None
Примеры:
# re.match (r'b(b)?x\1', 'bxb')   # группа не определена
# re.match (r'b(b?)x\1', 'bxb')   # группа пуста
# re.sub (r'(a)(b)?', r'_\1\2_', 'a')    #поведение зависит от версии
# re.match (r'(a)(b)?c', 'ac').groups()  # None
# re.findall (r'(a)(b)?c', 'ac')         # ''
# re.split (r'(s)(x)?', '_s_')           # None

4.5
Сколько будет найдено вхождений?
len (re.findall ('aa', 'a' * 100)

4.6
re.sub (r'bc|(?<=c)b', '', 'bcb')
Что будет?

4.7
Быстро ли будет работать?
re.match (r'(a+)+$', 'aaaaaaaaaaaaaaaaaaaaaaaaaaab')

4.8
Про backslash и символ, не соответствующий никакой специальной последовательности:
>>> re.findall (r'[\ё]', '\ё\\')  == ['ё']              
>>> re.findall (r'[\\ё]', '\ё\\') == ['\\', 'ё', '\\']
>>> re.findall ('\\ё', '\ё\\')    == ['ё']
Строка '\ё\\' состоит из трёх символов.
Последовательность \ё в определении шаблона регулярные выражения понимают как один символ.

4.9
Про \ooo (которой не стоит пользоваться)

Python 3.4.2:
>>> re.sub ('b', r'\777', 'b')
'ÿ'
>>> re.sub ('b', '\777', 'b')
'ǿ'
>>> ('\777', oct (ord ('ÿ')))
('ǿ', '0o377')

Python 3.6:
>>> re.sub ('b', r'\777', 'b')
sre_constants.error: octal escape value \777 outside of range 0-0o377 at position 0

4.10
Именованные группы: пример из модуля imaplib:
InternalDate = re.compile(r'INTERNALDATE "'
        r'(?P<day>[ 123][0-9])-(?P<mon>[A-Z][a-z][a-z])-'
        r'(?P<year>[0-9][0-9][0-9][0-9])'
        r' (?P<hour>[0-9][0-9]):(?P<min>[0-9][0-9]):(?P<sec>[0-9][0-9])'
        r' (?P<zonen>[-+])(?P<zoneh>[0-9][0-9])(?P<zonem>[0-9][0-9])'
        r'"')

4.11
Пример использования флага VERBOSE: эти два выражения эквивалентны:

pat = re.compile(r"\s*(?P<header>[^:]+)\s*:(?P<value>.*?)\s*$")

pat = re.compile(r"""
 \s*                 # Skip leading whitespace
 (?P<header>[^:]+)   # Header name
 \s* :               # Whitespace, and a colon
 (?P<value>.*?)      # The header's value -- *? used to
                     # lose the following trailing whitespace
 \s*$                # Trailing whitespace to end-of-line
""", re.VERBOSE)